<div th:fragment="component-file-picker-and-saver" th:remove="tag">
  <template>
    <div>
      <v-btn @click="createNewContentType">New</v-btn>
      <v-btn @click="getFileContent">Load</v-btn>
      <v-btn
        @click="saveContentType"
        color="green"
        :disabled="fileHandle == null"
        >Save</v-btn
      >
    </div>
  </template>

  <script th:inline="javascript">
    DOM = document.getElementsByTagName("template")[0];
    DOM.remove();

    Vue.component("component-file-picker-and-saver", {
      template: DOM.innerHTML.toString(),
      data() {
        return {
          fileHandle: null,
          error: {
            borderColor: "red",
            backgroundColor: "#ff000005",
          },
        };
      },
      methods: {
        async createNewContentType() {
          Swal.fire({
            text: "Please select the content-types folder.",
            showCancelButton: true,
          }).then(async (result) => {
            if (!result.isConfirmed) return;

            dirHandle = await window.showDirectoryPicker();

            if (dirHandle.name !== "content-types") {
              Swal.fire({
                icon: "warning",
                text: `Please select the content-types folder, you've selected a folder called ${dirHandle.name}.`,
              });
              return;
            }

            const { value: contentTypeName } = await Swal.fire({
              text: "What is the name of the content type?",
              input: "text",
            });

            if (!contentTypeName) return;

            const newContentTypeDirectoryHandle =
              await dirHandle.getDirectoryHandle(contentTypeName, {
                create: true,
              });

            this.fileHandle = await newContentTypeDirectoryHandle.getFileHandle(
              `${contentTypeName}.xml`,
              { create: true }
            );

            this.$store.commit("setFileName", { data: contentTypeName });
          });
        },
        async getFileContent() {
          Swal.fire({
            text: "Please select the xml file of a content-type.",
            showCancelButton: true,
          }).then(async (result) => {
            if (!result.isConfirmed) return;

            [fileHandle] = await window.showOpenFilePicker();
            this.fileHandle = fileHandle;
            const file = await fileHandle.getFile();

            if (file.type !== "text/xml") {
              Swal.fire({
                text: "This is not a XML file.",
                icon: "error",
                showConfirmButton: false,
                timer: 1500,
              });
              return false;
            }

            this.setJson(await file.text());

            Swal.fire({
              iconHtml: `<img class="loading-icon" src="${app.$root._data.loadingIcon}">`,
              customClass: {
                icon: "no-border",
              },
              showConfirmButton: false,
              timer: 500,
            }).then(() => {
              this.$store.commit("setFileName", {
                data: file.name.replace(".xml", ""),
              });
            });
          });
        },
        async saveContentType() {
          const isFormValid = app.$refs.form.validate();

          if (!isFormValid) {
            this.setBorderOfVcardsWithErrors();

            Swal.fire({
              icon: "error",
              showConfirmButton: false,
              timer: 1500,
            });

            return;
          }

          this.resetColorOfVcards();

          const xml = await this.getXmlFromJson(this.json);
          const writable = await this.fileHandle.createWritable();

          if (writable && xml) {
            await writable.write(xml);
            await writable.close();

            Swal.fire({
              icon: "success",
              showConfirmButton: false,
              timer: 1500,
            });
          } else {
            Swal.fire({
              icon: "error",
              showConfirmButton: false,
              timer: 1500,
            });
          }
        },

        ///

        setBorderOfVcardsWithErrors() {
          // Get all error DOM elements
          const getAllDOMelementsWithErrors = () =>
            Array.from(
              document.getElementsByClassName("v-messages error--text")
            );

          // For each error elements, find it's Vcard father and colorize it
          const colorizeElementsWithErrors = (elements) => {
            elements.forEach((div) => {
              let i = 0;
              let el = div;
              const m = 10;

              while (el && i < m) {
                if (isElementVCard(el)) {
                  break;
                } else {
                  el = el.parentElement;
                  i += 1;
                }
              }

              el.style.border = `2px solid ${this.error.borderColor}`;
              el.style.backgroundColor = this.error.backgroundColor;
            });

            return elements;
          };

          // Expand all parent elements of el
          const expandAllParentElements = (elements) => {
            elements.forEach((el) => {
              getAllElementParents(el)
                .filter((el) => isElementVCard(el))
                .forEach((el) => {
                  el.__vue__.$parent.showConfig = true;
                });
            });
          };

          ///

          // Check if an element is a vuetify card
          const isElementVCard = (el) => {
            return (
              (((el.__vue__ || {}).$options || {})._componentTag || "") ===
              "v-card"
            );
          };

          // Get all father parents of el
          const getAllElementParents = (el) => {
            return [
              ...(function* (e) {
                do {
                  yield e;
                } while ((e = e.parentNode));
              })(el),
            ];
          };

          ///

          setTimeout(() => {
            R.pipe(
              getAllDOMelementsWithErrors,
              colorizeElementsWithErrors,
              expandAllParentElements
            )();
          }, 100);
        },
        resetColorOfVcards() {
          Array.from(document.getElementsByClassName("v-card")).forEach(
            (div) => {
              div.style.border = "";
              div.style.backgroundColor = "";
            }
          );
        },

        ///

        setJson(xml) {
          const xmlWithoutComments = xml.replaceAll(/<!--[\s\S]*?-->/g, "");
          const request = { mode: "xml2json", xml: xmlWithoutComments };
          fetch(
            "http://localhost:8080/_/service/tool.content.type.manager/test",
            {
              method: "POST",
              body: JSON.stringify(request),
            }
          )
            .then((response) => response.json())
            .then((data) => {
              this.$store.commit("setJson", { data: data.json });
            });
        },
        async getXmlFromJson(json) {
          const request = { mode: "json2xml", json };

          return fetch(
            "http://localhost:8080/_/service/tool.content.type.manager/test",
            {
              method: "POST",
              body: JSON.stringify(request),
            }
          )
            .then((response) => response.json())
            .then((data) => data.xml);
        },
      },
      computed: {
        json() {
          return this.$store.state.moduleExample.json;
        },
      },
    });
  </script>
</div>
