<div th:fragment="component-file-picker-and-saver" th:remove="tag">
  <template>
    <div>
      <v-btn @click="newCty">New</v-btn>
      <v-btn @click="loadCty">Load</v-btn>
      <v-btn
        @click="saveCty"
        color="green"
        :disabled="!fileName"
        >Save</v-btn
      >
    </div>
  </template>

  <script th:inline="javascript">
    DOM = document.getElementsByTagName("template")[0];
    DOM.remove();

    Vue.component("component-file-picker-and-saver", {
      template: DOM.innerHTML.toString(),
      data() {
        return {
          fileHandle: null,
          warnings: {
            'select-cty-folder': "Please select the content-types folder.",
            'incorrect-cty-folder': (selectedFolderName) => `Please select the content-types folder, you've selected a folder named ${selectedFolderName}.`,
            'select-xml': "Please select the xml file of a content-type.",
            'file-not-xml': "This is not a XML file.",
            'incompatible-browser': "This application is using features that are currently not supported by your browser. Please use Google Chrome."
          }
        };
      },
      methods: {
        newCty(){
          if(this.checkBrowserCompatibility()){
            this.fileHandle = null;
            this.$store.commit("resetJson");
            this.$store.commit("setFileName", { data: ' ' });
          }
        },
        async loadCty() {
          if(this.checkBrowserCompatibility()){
            Swal.fire({
              text: this.warnings['select-xml'],
              showCancelButton: true,
            }).then(async (result) => {
              if (!result.isConfirmed) return;

              [fileHandle] = await window.showOpenFilePicker();
              this.fileHandle = fileHandle;
              const file = await fileHandle.getFile();

              if (file.type !== "text/xml") {
                Swal.fire({
                  text: this.warnings['file-not-xml'],
                  icon: "error",
                  showConfirmButton: false,
                  timer: 1500,
                });
                this.fileHandle = null;
                return false;
              }

              this.setJson(await file.text());

              Swal.fire({
                iconHtml: `<img class="loading-icon" src="${app.$root._data.loadingIcon}">`,
                customClass: {
                  icon: "no-border",
                },
                showConfirmButton: false,
                timer: 1500,
              }).then(() => {
                this.$store.commit("setFileName", {
                  data: file.name.replace(".xml", ""),
                });
              });
            });
          }
        },
        async saveCty(){
          if(this.fileHandle){
            await this.saveContentType();
          }else{
            this.createNewContentType()
              .then((lastStepResult) => { lastStepResult && this.saveContentType() });
          }
        },

        async createNewContentType() {
          // 1 - Select folder
          const showFirstDialog = async () => {
            return Swal.fire({
              text: this.warnings['select-cty-folder'],
              showCancelButton: true,
            }).then(async (result) => result.isConfirmed);
          };

          // 2 - Validate if selected folder is called 'content-types'
          // and return the dirHandle
          const selectFolderAndReturnDirectoryHandle = async (
            userAcceptedToContinue
          ) => {
            if (!userAcceptedToContinue) return {};

            dirHandle = await window.showDirectoryPicker();

            if (dirHandle.name !== "content-types") {
              Swal.fire({
                icon: "warning",
                text: this.warnings['incorrect-cty-folder'](dirHandle.name),
              });
              return {};
            }

            return dirHandle;
          };

          // 3 - Check if the name of the new content type is valid
          const checkIfContentTypeNameIsValid = async (dirHandle) => {
            if (!("name" in dirHandle)) {
              return { nameIsValid: false, ctyName: "" };
            }

            let ctyName = "";
            const existingCtyNames = [];

            // Get all existing content type names
            for await (const entry of dirHandle.values()) {
              entry.kind === "directory" && existingCtyNames.push(entry.name);
            }

            const isCtyNameValid = (ctyName) =>
              ctyName.length > 0 &&
              !ctyName.includes(" ");

            const ctyNameExists = (ctyName, existingCtyNames) =>
              existingCtyNames.indexOf(ctyName) === -1;

            const dialogText = (ctyName, existingCtyNames) => {
              if(!ctyName) return "What is the name of the new content type?"

              let errorMessages = [];
              if(!isCtyNameValid(ctyName)){
                errorMessages.push('is invalid');
              }
              if(!ctyNameExists(ctyName, existingCtyNames)){
                errorMessages.push('is used by another content type');
              }

              if(errorMessages.length > 0){
                return `<b>"${ctyName}"</b> ${errorMessages.join(' and ')}. Please provide a different name.`
              }
            };

            do {
              const text = dialogText(ctyName, existingCtyNames);
              const r = await Swal.fire({ html: text, input: "text" });
              ctyName = r.value;
            } while (
              !isCtyNameValid(ctyName, existingCtyNames) ||
              !ctyNameExists(ctyName, existingCtyNames)
            );

            return { nameIsValid: true, ctyName };
          };

          // 4 - Create the directory and the xml files for the content type
          const createDirAndXmlFile = async (nameIsValid, ctyName) => {
            if (!nameIsValid) return false;

            const newContentTypeDirectoryHandle =
              await dirHandle.getDirectoryHandle(ctyName, {
                create: true,
              });

            this.fileHandle = await newContentTypeDirectoryHandle.getFileHandle(
              `${ctyName}.xml`,
              { create: true }
            );

            this.$store.commit("setFileName", { data: ctyName });

            return true;
          };

          if(this.checkBrowserCompatibility()){
            return showFirstDialog()
              .then((userAcceptedToContinue) =>
                selectFolderAndReturnDirectoryHandle(userAcceptedToContinue)
              )
              .then((dirHandle) => checkIfContentTypeNameIsValid(dirHandle))
              .then(({ nameIsValid, ctyName }) =>
                createDirAndXmlFile(nameIsValid, ctyName)
              );
          }
        },
        async saveContentType() {
          const isFormValid = app.$refs.form.validate();

          this.resetColorOfVcards();

          if (!isFormValid) {
            this.setBorderOfVcardsWithErrors();

            Swal.fire({
              icon: "error",
              showConfirmButton: false,
              timer: 1500,
            });

            return;
          }

          const xml = await this.getXmlFromJson(this.json);
          const writable = await this.fileHandle.createWritable();

          if (writable && xml) {
            await writable.write(xml);
            await writable.close();

            Swal.fire({
              icon: "success",
              showConfirmButton: false,
              timer: 1500,
            });
          } else {
            Swal.fire({
              icon: "error",
              showConfirmButton: false,
              timer: 1500,
            });
          }
        },
        
        ///

        checkBrowserCompatibility(){
          if(!window.showDirectoryPicker || !window.showOpenFilePicker){
            Swal.fire({
              text: this.warnings['incompatible-browser'],
              icon: "warning",
            });
            return false;
          }
          return true;
        },
        setBorderOfVcardsWithErrors() {
          // Get all error DOM elements
          const getAllDOMelementsWithErrors = () =>
            Array.from(
              document.getElementsByClassName("v-messages error--text")
            );

          // For each error elements, find it's Vcard father and colorize it
          const colorizeElementsWithErrors = (elements) => {
            elements.forEach((div) => {
              let i = 0;
              let el = div;
              const m = 10;

              while (el && i < m) {
                if (isElementVCard(el)) {
                  break;
                } else {
                  el = el.parentElement;
                  i += 1;
                }
              }

              el.classList.add("v-card-error");
            });

            return elements;
          };

          // Expand all parent elements of el
          const expandAllParentElements = (elements) => {
            elements.forEach((el) => {
              getAllElementParents(el)
                .filter((el) => isElementVCard(el))
                .forEach((el) => {
                  el.__vue__.$parent.showConfig = true;
                });
            });
          };

          ///

          // Check if an element is a vuetify card
          const isElementVCard = (el) => {
            return (
              (((el.__vue__ || {}).$options || {})._componentTag || "") ===
              "v-card"
            );
          };

          // Get all father parents of el
          const getAllElementParents = (el) => {
            const parents = [];
            do {
              parents.push(el);
            } while ((el = el.parentNode));
            return parents;
          };

          ///

          setTimeout(() => {
            const elementsWithErrors = getAllDOMelementsWithErrors();
            colorizeElementsWithErrors(elementsWithErrors);
            expandAllParentElements(elementsWithErrors);
          }, 100);
        },
        resetColorOfVcards() {
          Array.from(document.getElementsByClassName("v-card")).forEach((el) =>
            el.classList.remove("v-card-error")
          );
        },

        ///

        setJson(xml) {
          const xmlWithoutComments = xml.replaceAll(/<!--[\s\S]*?-->/g, "");
          const request = { mode: "xml2json", xml: xmlWithoutComments };
          fetch(
            "http://localhost:8080/_/service/tool.content.type.manager/test",
            {
              method: "POST",
              body: JSON.stringify(request),
            }
          )
            .then((response) => response.json())
            .then((data) => {
              this.$store.commit("setJson", { data: data.json });
            });
        },
        async getXmlFromJson(json) {
          const request = { mode: "json2xml", json };

          return fetch(
            "http://localhost:8080/_/service/tool.content.type.manager/test",
            {
              method: "POST",
              body: JSON.stringify(request),
            }
          )
            .then((response) => response.json())
            .then((data) => data.xml);
        },
      },
      computed: {
        json() {
          return this.$store.state.moduleExample.json;
        },
        fileName() {
          return this.$store.getters.fileName;
        },
      },
    });
  </script>
</div>
