<div th:fragment="component-file-picker-and-saver" th:remove="tag">
  <template>
    <div :class="'d-flex flex-column' + (!fileName ? ' h-100' : '')">
      <div>
        <v-btn @click="newCty">New</v-btn>
        <v-btn @click="loadCty">Load</v-btn>
        <v-btn
          class="float-end"
          @click="saveCty"
          color="green"
          :disabled="!fileName"
          >Save</v-btn>
      </div>
      <div
        v-if="!fileName"
        class="d-flex align-center justify-center h-100">
        <p class="new-schema-placeholder"> {{ placeholderText }} </p>
      </div>
    </div>
  </template>

  <script th:inline="javascript">
    DOM = document.getElementsByTagName("template")[0];
    DOM.remove();

    Vue.component("component-file-picker-and-saver", {
      template: DOM.innerHTML.toString(),
      data() {
        return {
          previousJson: {},
          fileHandle: null,
          placeholderText: "Use NEW/LOAD buttons to create or open a content type schema.",
          dialogMessages: {
            'save': "Your changes have been saved.",
            'load': "Loading content type schema...",
            'error': "Failed to save the content type schema.",
            'select-cty-folder': "Please select the content-types folder.",
            'incorrect-cty-folder': (selectedFolderName) => `Please select the content-types folder, you've selected a folder named ${selectedFolderName}.`,
            'select-xml': "Please select a content type XML schema.",
            'file-not-xml': "This is not a XML file.",
            'incompatible-browser': "This application is using features that are currently not supported by your browser. Please use Google Chrome.",
            'changes': "You have made changes to the schema which will be lost if you continue. Do you want to save your changes ?",
          }
        };
      },
      mounted(){
        this.previousJson = this.copyObject(this.json);
      },
      methods: {
        async newCty(){

          if(!this.checkBrowserCompatibility()){
            this.showIncompatibleBrowserDialog();
            return;
          }

          await this.suggestSaveIfChangesExists();

          this.fileHandle = null;
          this.$store.commit("resetJson");
          this.$store.commit("setFileName", { data: ' ' });
          this.previousJson = this.copyObject(this.json);
        },
        async loadCty() {

          if(!this.checkBrowserCompatibility()){
            this.showIncompatibleBrowserDialog();
            return;
          }

          await this.suggestSaveIfChangesExists();

          const showSelectXmlDialog = async () => {
            return Swal.fire({
              text: this.dialogMessages['select-xml'],
              showCancelButton: true,
            }).then(async (result) => {
              if(!result.isConfirmed) { return Promise.reject(); }
            })
          }

          const setFileHandler = async () => {
            [fileHandle] = await window.showOpenFilePicker();
            this.fileHandle = fileHandle;
            const file = await fileHandle.getFile();
            
            if(!file){ return Promise.reject(); }

            return file;
          }

          const checkIfFileIsXml = (file) => {
            if (file.type !== "text/xml") {
              throw this.dialogMessages['file-not-xml'];
            }
          }

          const showLoadingDialog = (file) => {
            Swal.fire({
              iconHtml: `<img class="loading-icon" src="${app.$root._data.loadingIcon}">`,
              text: this.dialogMessages.load,
              customClass: { icon: "no-border" },
              showConfirmButton: false,
              timer: 1500,
            }).then(() => {
              this.$store.commit("setFileName", {
                data: file.name.replace(".xml", ""),
              });
            });
          }

          showSelectXmlDialog()
            .then(() => setFileHandler())
            .then(async (file) => {
              checkIfFileIsXml(file);
              showLoadingDialog(file);
              this.setJson(await file.text());
            })
            .catch((error) => {
              error && Swal.fire({
                icon: "error",
                text: error,
                showConfirmButton: false,
                timer: 2000,
              })
            });
        },
        async saveCty(){
          this.resetColorOfVcards();

          if(!this.checkBrowserCompatibility()){
            this.showIncompatibleBrowserDialog();
            return;
          }          
          
          if (!app.$refs.form.validate()) {
            this.setBorderOfVcardsWithErrors();
            this.showValidationErrorDialog();
            return;
          }

          if(this.fileHandle){
            await this.saveContentType();
          }else{
            this.createNewContentType()
              .then((lastStepResult) => { lastStepResult && this.saveContentType() });
          }
        },

        async createNewContentType() {
          // 1 - Select folder
          const showFirstDialog = async () => {
            return Swal.fire({
              text: this.dialogMessages['select-cty-folder'],
              showCancelButton: true,
            }).then(async (result) => result.isConfirmed);
          };

          // 2 - Validate if selected folder is called 'content-types'
          // and return the dirHandle
          const selectFolderAndReturnDirectoryHandle = async (
            userAcceptedToContinue
          ) => {
            if (!userAcceptedToContinue) return {};

            dirHandle = await window.showDirectoryPicker();

            if (dirHandle.name !== "content-types") {
              Swal.fire({
                icon: "warning",
                text: this.dialogMessages['incorrect-cty-folder'](dirHandle.name),
              });
              return {};
            }

            return dirHandle;
          };

          // 3 - Check if the name of the new content type is valid
          const checkIfContentTypeNameIsValid = async (dirHandle) => {
            if (!("name" in dirHandle)) {
              return { nameIsValid: false, ctyName: "" };
            }

            let ctyName = "";
            const existingCtyNames = [];

            // Get all existing content type names
            for await (const entry of dirHandle.values()) {
              entry.kind === "directory" && existingCtyNames.push(entry.name);
            }

            const isCtyNameValid = (ctyName) =>
              ctyName.length > 0 &&
              !ctyName.includes(" ");

            const ctyNameExists = (ctyName, existingCtyNames) =>
              existingCtyNames.indexOf(ctyName) === -1;

            const dialogText = (ctyName, existingCtyNames) => {
              if(!ctyName) return "What is the name of the new content type?"

              let errorMessages = [];
              if(!isCtyNameValid(ctyName)){
                errorMessages.push('is invalid');
              }
              if(!ctyNameExists(ctyName, existingCtyNames)){
                errorMessages.push('is used by another content type');
              }

              if(errorMessages.length > 0){
                return `<b>"${ctyName}"</b> ${errorMessages.join(' and ')}. Please provide a different name.`
              }
            };

            do {
              const text = dialogText(ctyName, existingCtyNames);
              const r = await Swal.fire({ html: text, input: "text" });
              ctyName = r.value;
            } while (
              !isCtyNameValid(ctyName, existingCtyNames) ||
              !ctyNameExists(ctyName, existingCtyNames)
            );

            return { nameIsValid: true, ctyName };
          };

          // 4 - Create the directory and the xml files for the content type
          const createDirAndXmlFile = async (nameIsValid, ctyName) => {
            if (!nameIsValid) return false;

            const newContentTypeDirectoryHandle =
              await dirHandle.getDirectoryHandle(ctyName, {
                create: true,
              });

            this.fileHandle = await newContentTypeDirectoryHandle.getFileHandle(
              `${ctyName}.xml`,
              { create: true }
            );

            this.$store.commit("setFileName", { data: ctyName });

            return true;
          };

          
          return showFirstDialog()
            .then((userAcceptedToContinue) =>
              selectFolderAndReturnDirectoryHandle(userAcceptedToContinue)
            )
            .then((dirHandle) => checkIfContentTypeNameIsValid(dirHandle))
            .then(({ nameIsValid, ctyName }) =>
              createDirAndXmlFile(nameIsValid, ctyName)
            );
        },
        async saveContentType() {

          const xml = await this.getXmlFromJson(this.json);
          const writable = await this.fileHandle.createWritable();

          if (writable && xml) {
            await writable.write(xml);
            await writable.close();

            Swal.fire({
              icon: "success",
              text: this.dialogMessages.save,
              showConfirmButton: false,
              timer: 1500,
            }).then(() => {
              this.previousJson = this.copyObject(this.json);
            });
          } else {
            Swal.fire({
              icon: "error",
              text: this.dialogMessages.error,
              showConfirmButton: false,
              timer: 1500,
            });
          }
        },
        async suggestSaveIfChangesExists(){
          const changesExists = JSON.stringify(this.previousJson) !== JSON.stringify(this.json);

          if(!changesExists) return true;
          
          // If there are changes, then asks for saving the cty
          return await Swal.fire({
            icon: "warning",
            text: this.dialogMessages.changes,
            showDenyButton: true,
            showCancelButton: false,
            confirmButtonText: 'Yes',
            denyButtonText: 'No',
          }).then((result) => result.isConfirmed && this.saveCty())
        },
        
        checkBrowserCompatibility() {
          return window.showDirectoryPicker && window.showOpenFilePicker;
        },
        setBorderOfVcardsWithErrors() {
          // Get all error DOM elements
          const getAllDOMelementsWithErrors = () =>
            Array.from(document.getElementsByClassName("v-messages error--text"));

          // For each error elements, find it's Vcard father and colorize it
          const colorizeElementsWithErrors = (elements) => {
            elements.forEach((div) => {
              let el = div;
              while (! isElementVCard(el) && el.parentElement) { el = el.parentElement };
              el.classList.add("v-card-error");
            });

            return elements;
          };

          // Expand all parent elements of el
          const expandAllParentElements = (elements) => {
            elements.forEach((el) => {
              getAllElementParents(el)
                .filter((el) => isElementVCard(el))
                .forEach((el) => {
                  el.__vue__.showConfig = true;
                  el.__vue__.$parent.showConfig = true;
                });
            });
          };

          ///

          // Check if an element is a vuetify card
          const isElementVCard = (el) => 
            el && el.classList && Array.from(el.classList).indexOf('v-card') >= 0 || false;

          // Get all father parents of el
          const getAllElementParents = (el) => {
            const parents = [];
            do {
              parents.push(el);
            } while ((el = el.parentNode));
            return parents;
          };

          ///

          setTimeout(() => {
            const elementsWithErrors = getAllDOMelementsWithErrors();
            colorizeElementsWithErrors(elementsWithErrors);
            expandAllParentElements(elementsWithErrors);
          }, 100);
        },
        resetColorOfVcards() {
          Array.from(document.getElementsByClassName("v-card")).forEach((el) =>
            el.classList.remove("v-card-error")
          );
        },
        showIncompatibleBrowserDialog() {
          Swal.fire({
            text: this.dialogMessages['incompatible-browser'],
            icon: "warning",
          });
        },
        showValidationErrorDialog() {
          Swal.fire({
            icon: "error",
            text: this.dialogMessages.error,
            showConfirmButton: false,
            timer: 1500,
          });
        },
        copyObject(obj) {
          return JSON.parse(JSON.stringify(obj));
        },
        setJson(xml) {
          const xmlWithoutComments = xml.replaceAll(/<!--[\s\S]*?-->/g, "");
          const request = { mode: "xml2json", xml: xmlWithoutComments };
          fetch(
            app.$root._data.services.xml2JsonConverter,
            {
              method: "POST",
              body: JSON.stringify(request),
            }
          )
            .then((response) => response.json())
            .then((data) => {
              this.previousJson = this.copyObject(this.json);
              this.$store.commit("setJson", { data: data.json });
            });
        },
        async getXmlFromJson(json) {
          const request = { mode: "json2xml", json };

          return fetch(
            app.$root._data.services.xml2JsonConverter,
            {
              method: "POST",
              body: JSON.stringify(request),
            }
          )
            .then((response) => response.json())
            .then((data) => data.xml);
        },
      },
      computed: {
        json() {
          return this.$store.state.moduleExample.json;
        },
        fileName() {
          return this.$store.getters.fileName;
        },
      },
    });
  </script>
</div>
